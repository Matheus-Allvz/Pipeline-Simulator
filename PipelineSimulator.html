<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Pipeline e Cache (RV32I)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .font-mono {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200">

    <div class="container mx-auto p-4 max-w-7xl">
        <h1 class="text-3xl font-bold text-center mb-6">Simulador de Pipeline e Cache (RV32I)</h1>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">

            <div class="bg-gray-800 p-4 rounded-lg shadow-lg">
                <h2 class="text-xl font-semibold mb-4">Configuração</h2>
                
                <label for="code-input" class="block mb-2 font-medium">Código Assembly (RV32I):</label>
                <textarea id="code-input" rows="10" class="w-full p-2 bg-gray-900 text-gray-100 rounded border border-gray-700 font-mono" placeholder="addi x1, x0, 10&#10;addi x2, x0, 20&#10;add x3, x1, x2&#10;sw x3, 4(x0)&#10;lw x4, 4(x0)&#10;beq x1, x2, 2&#10;jal x5, 4"></textarea>
                
                <button id="load-program" class="w-full mt-2 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">
                    Carregar Programa
                </button>

                <h3 class="text-lg font-semibold mt-6 mb-3">Configurações da Cache (Placeholder)</h3>
                <div class="space-y-2">
                    <div>
                        <label for="l1i-latency" class="text-sm">Latência L1I:</label>
                        <input type="number" id="l1i-latency" value="1" class="w-full p-1 bg-gray-700 rounded" disabled>
                    </div>
                    <div>
                        <label for="l1d-latency" class="text-sm">Latência L1D:</label>
                        <input type="number" id="l1d-latency" value="1" class="w-full p-1 bg-gray-700 rounded" disabled>
                    </div>
                    <div>
                        <label for="miss-penalty" class="text-sm">Penalidade de Miss:</label>
                        <input type="number" id="miss-penalty" value="10" class="w-full p-1 bg-gray-700 rounded" disabled>
                    </div>
                </div>
            </div>

            <div class="bg-gray-800 p-4 rounded-lg shadow-lg">
                <h2 class="text-xl font-semibold mb-4">Estado do Pipeline</h2>
                <table class="w-full table-auto font-mono">
                    <thead class="border-b border-gray-600">
                        <tr>
                            <th class="text-left py-2 px-1">Estágio</th>
                            <th class="text-left py-2 px-1">Instrução</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td class="font-bold py-1 px-1">IF (Busca)</td>
                            <td id="pipeline-if" class="py-1 px-1">vazio</td>
                        </tr>
                        <tr>
                            <td class="font-bold py-1 px-1">ID (Decod.)</td>
                            <td id="pipeline-id" class="py-1 px-1">vazio</td>
                        </tr>
                        <tr>
                            <td class="font-bold py-1 px-1">EX (Exec.)</td>
                            <td id="pipeline-ex" class="py-1 px-1">vazio</td>
                        </tr>
                        <tr>
                            <td class="font-bold py-1 px-1">MEM (Memória)</td>
                            <td id="pipeline-mem" class="py-1 px-1">vazio</td>
                        </tr>
                        <tr>
                            <td class="font-bold py-1 px-1">WB (Escrita)</td>
                            <td id="pipeline-wb" class="py-1 px-1">vazio</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="bg-gray-800 p-4 rounded-lg shadow-lg">
                <h2 class="text-xl font-semibold mb-4">Estado do Sistema</h2>

                <h3 class="text-lg font-semibold mb-2">Métricas</h3>
                <table class="w-full table-auto mb-4 font-mono">
                    <tbody>
                        <tr>
                            <td class="py-1">PC:</td>
                            <td id="metrics-pc" class="text-right">0</td>
                        </tr>
                        <tr>
                            <td class="py-1">Ciclos:</td>
                            <td id="metrics-cycles" class="text-right">0</td>
                        </tr>
                        <tr>
                            <td class="py-1">Instruções:</td>
                            <td id="metrics-instructions" class="text-right">0</td>
                        </tr>
                        <tr>
                            <td class="py-1">CPI:</td>
                            <td id="metrics-cpi" class="text-right">0.00</td>
                        </tr>
                    </tbody>
                </table>
                
                <h3 class="text-lg font-semibold mb-2">Registradores (x0-x31)</h3>
                <div class="max-h-80 overflow-y-auto border border-gray-700 rounded">
                    <table class="w-full table-auto font-mono text-sm">
                        <thead class="bg-gray-700 sticky top-0">
                            <tr>
                                <th class="text-left py-1 px-2">Reg</th>
                                <th class="text-left py-1 px-2">Valor (Hex)</th>
                                <th class="text-left py-1 px-2">Valor (Dec)</th>
                            </tr>
                        </thead>
                        <tbody id="registers-table-body">
                            </tbody>
                    </table>
                </div>
            </div>

        </div>

        <div class="mt-6 p-4 bg-gray-800 rounded-lg shadow-lg text-center">
            <h2 class="text-xl font-semibold mb-4">Controles</h2>
            <button id="btn-step" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded mr-2">
                Executar (Cycle)
            </button>
            <button id="btn-run" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-6 rounded mr-2">
                Executar (Completo)
            </button>
            <button id="btn-reset" class="bg-red-600 hover:bg-red-600 text-white font-bold py-2 px-6 rounded">
                Resetar
            </button>
        </div>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            const simulator = {
                // Estado do Sistema
                registers: new Array(32).fill(0),
                dataMemory: new Uint8Array(1024), // 1KB de memória de dados
                instructionMemory: [],
                pc: 0,

                // Estado do Pipeline (agora são os "latches" entre estágios)
                pipelineStages: {
                    IF_UI: null, // Apenas para UI: instrução buscada *neste* ciclo
                    ID: null,    // Latch IF/ID
                    EX: null,    // Latch ID/EX
                    MEM: null,   // Latch EX/MEM
                    WB: null,    // Latch MEM/WB
                },

                // Métricas
                metrics: {
                    cycles: 0,
                    instructions: 0,
                },

                // Referências da UI (sem alteração)
                ui: {
                    pipeline: {
                        if: document.getElementById('pipeline-if'),
                        id: document.getElementById('pipeline-id'),
                        ex: document.getElementById('pipeline-ex'),
                        mem: document.getElementById('pipeline-mem'),
                        wb: document.getElementById('pipeline-wb'),
                    },
                    metrics: {
                        pc: document.getElementById('metrics-pc'),
                        cycles: document.getElementById('metrics-cycles'),
                        instructions: document.getElementById('metrics-instructions'),
                        cpi: document.getElementById('metrics-cpi'),
                    },
                    registersTableBody: document.getElementById('registers-table-body'),
                    buttons: {
                        step: document.getElementById('btn-step'),
                        run: document.getElementById('btn-run'),
                        reset: document.getElementById('btn-reset'),
                        loadProgram: document.getElementById('load-program'),
                    },
                    codeInput: document.getElementById('code-input'),
                },

                // --- FUNÇÕES DE INICIALIZAÇÃO E PARSER (sem alteração) ---
                init: function() {
                    console.log("Simulador iniciado.");
                    this.buildRegisterTable();
                    this.reset();
                    this.setupEventListeners();
                },
                buildRegisterTable: function() {
                    let html = '';
                    for (let i = 0; i < 32; i++) {
                        html += `
                            <tr class="border-t border-gray-700 hover:bg-gray-700">
                                <td class="py-1 px-2 font-bold">x${i}</td>
                                <td class="py-1 px-2" id="reg-hex-${i}">0x00000000</td>
                                <td class="py-1 px-2" id="reg-dec-${i}">0</td>
                            </tr>`;
                    }
                    this.ui.registersTableBody.innerHTML = html;
                },
                setupEventListeners: function() {
                    this.ui.buttons.step.addEventListener('click', this.step.bind(this));
                    this.ui.buttons.run.addEventListener('click', this.run.bind(this));
                    this.ui.buttons.reset.addEventListener('click', this.reset.bind(this));
                    this.ui.buttons.loadProgram.addEventListener('click', this.loadProgram.bind(this));
                },
                
                // --- ATUALIZADO ---
                reset: function() {
                    console.log("Resetando simulador...");
                    this.registers.fill(0);
                    this.dataMemory.fill(0);
                    this.instructionMemory = [];
                    this.pc = 0;
                    
                    this.pipelineStages = {
                        IF_UI: null, ID: null, EX: null, MEM: null, WB: null,
                    };
                    
                    this.metrics = { cycles: 0, instructions: 0 };
                    this.updateUI();
                },
                loadProgram: function() {
                    console.log("Carregando programa...");
                    this.reset();
                    const code = this.ui.codeInput.value;
                    this.parse(code);
                    console.log("Programa carregado:", this.instructionMemory);
                    this.updateUI();
                },
                parseRegister: function(r) {
                    if (!r) return NaN;
                    return parseInt(r.replace('x', '').replace('r', ''));
                },
                parse: function(code) {
                    const lines = code.split('\n');
                    
                    lines.forEach(line => {
                        let trimmedLine = line.split('#')[0].split('//')[0].trim();
                        if (!trimmedLine) return;
                        const parts = trimmedLine.replace(/,/g, '').replace(/\(/, ' ').replace(/\)/, '').split(/\s+/).filter(p => p);
                        if (parts.length === 0) return;

                        const op = parts[0].toLowerCase();
                        let inst = { op: op, line: trimmedLine };

                        try {
                            switch (op) {
                                case 'add': case 'sub':
                                    inst.rd = this.parseRegister(parts[1]);
                                    inst.rs1 = this.parseRegister(parts[2]);
                                    inst.rs2 = this.parseRegister(parts[3]);
                                    break;
                                case 'addi':
                                    inst.rd = this.parseRegister(parts[1]);
                                    inst.rs1 = this.parseRegister(parts[2]);
                                    inst.imm = parseInt(parts[3]);
                                    break;
                                case 'lw':
                                    inst.rd = this.parseRegister(parts[1]);
                                    inst.imm = parseInt(parts[2]);
                                    inst.rs1 = this.parseRegister(parts[3]);
                                    break;
                                case 'sw':
                                    inst.rs2 = this.parseRegister(parts[1]);
                                    inst.imm = parseInt(parts[2]);
                                    inst.rs1 = this.parseRegister(parts[3]);
                                    break;
                                case 'beq':
                                    inst.rs1 = this.parseRegister(parts[1]);
                                    inst.rs2 = this.parseRegister(parts[2]);
                                    inst.imm = parseInt(parts[3]);
                                    break;
                                case 'jal':
                                    inst.rd = this.parseRegister(parts[1]);
                                    inst.imm = parseInt(parts[2]);
                                    break;
                                default:
                                    console.warn(`Instrução desconhecida ignorada: ${trimmedLine}`);
                                    return; // Correção do 'continue'
                            }
                            this.instructionMemory.push(inst);
                        } catch (e) {
                            console.error(`Erro ao parsear a linha: "${trimmedLine}"`, e);
                        }
                    });
                },

                // --- FUNÇÕES DO PIPELINE (NOVAS E ATUALIZADAS) ---

                /**
                 * Estágio WB (Write-Back)
                 * Executa a escrita no banco de registradores.
                 */
                doWB: function() {
                    const inst = this.pipelineStages.WB; // Lê do latch MEM/WB
                    if (!inst) return;

                    // Instruções que escrevem de volta: R-type, I-type, LW, JAL
                    const op = inst.op;
                    if (op === 'add' || op === 'sub' || op === 'addi' || op === 'lw' || op === 'jal') {
                        // Importante: Não escrever no registrador x0 (zero)
                        if (inst.rd > 0) {
                            // O valor 'writeBackData' foi calculado no estágio MEM
                            this.registers[inst.rd] = inst.writeBackData;
                        }
                    }
                    
                    // Instrução concluída!
                    this.metrics.instructions++;
                },

                /**
                 * Estágio MEM (Memory Access)
                 * Executa leitura (lw) ou escrita (sw) na memória.
                 * Passa o resultado (da ULA ou da memória) para o estágio WB.
                 */
                doMEM: function() {
                    const inst = this.pipelineStages.MEM; // Lê do latch EX/MEM
                    
                    // Passa a instrução para o próximo estágio (WB)
                    this.pipelineStages.WB = inst;
                    if (!inst) return;

                    const op = inst.op;
                    switch (op) {
                        case 'lw': {
                            // 'aluResult' contém o endereço de memória calculado em EX
                            const addr = inst.aluResult;
                            // Lê 4 bytes (Little Endian)
                            const b1 = this.dataMemory[addr]     || 0;
                            const b2 = this.dataMemory[addr + 1] || 0;
                            const b3 = this.dataMemory[addr + 2] || 0;
                            const b4 = this.dataMemory[addr + 3] || 0;
                            
                            // Combina os bytes em um inteiro de 32 bits
                            // (b4 << 24) | ... é para C/C++, em JS usamos | 0 para forçar 32-bit signed
                            inst.writeBackData = (b4 << 24) | (b3 << 16) | (b2 << 8) | b1;
                            break;
                        }
                        case 'sw': {
                            // 'aluResult' é o endereço, 'rs2Val' (de ID) é o dado
                            const addr = inst.aluResult;
                            const data = inst.rs2Val;
                            // Escreve 4 bytes (Little Endian)
                            this.dataMemory[addr]     = data & 0xFF;
                            this.dataMemory[addr + 1] = (data >> 8) & 0xFF;
                            this.dataMemory[addr + 2] = (data >> 16) & 0xFF;
                            this.dataMemory[addr + 3] = (data >> 24) & 0xFF;
                            break;
                        }
                        default:
                            // Para R-type, I-type (addi), apenas passa o resultado da ULA
                            if (inst.aluResult !== undefined) {
                                inst.writeBackData = inst.aluResult;
                            }
                            break;
                    }
                },

                /**
                 * Estágio EX (Execute)
                 * Executa a operação da ULA.
                 * Passa o resultado para o estágio MEM.
                 */
                doEX: function() {
                    const inst = this.pipelineStages.EX; // Lê do latch ID/EX
                    
                    // Passa a instrução para o próximo estágio (MEM)
                    this.pipelineStages.MEM = inst;
                    if (!inst) return;

                    // Os valores 'rs1Val' e 'rs2Val' foram lidos em ID
                    const op = inst.op;
                    switch (op) {
                        case 'add':
                            inst.aluResult = (inst.rs1Val + inst.rs2Val) | 0; // | 0 força 32-bit int
                            break;
                        case 'sub':
                            inst.aluResult = (inst.rs1Val - inst.rs2Val) | 0;
                            break;
                        case 'addi':
                            inst.aluResult = (inst.rs1Val + inst.imm) | 0;
                            break;
                        case 'lw':
                        case 'sw':
                            // Calcula o endereço de memória
                            inst.aluResult = (inst.rs1Val + inst.imm) | 0;
                            break;
                        case 'jal':
                            // Calcula o valor de retorno (PC+4, ou PC+1 no nosso índice)
                            // O 'pc' da instrução foi salvo em 'doIF'
                            inst.aluResult = inst.pc + 1; 
                            break;
                        case 'beq':
                            // Por enquanto não faz nada (nenhum desvio)
                            break;
                    }
                },

                /**
                 * Estágio ID (Instruction Decode)
                 * Decodifica a instrução e lê os registradores.
                 * Passa para o estágio EX.
                 */
                doID: function() {
                    const inst = this.pipelineStages.ID; // Lê do latch IF/ID
                    
                    // Passa a instrução para o próximo estágio (EX)
                    this.pipelineStages.EX = inst;
                    if (!inst) return;

                    // Decodifica: Lê valores dos registradores
                    // (Sem tratamento de hazard de dados ainda)
                    if (inst.rs1 !== undefined) {
                        inst.rs1Val = (inst.rs1 === 0) ? 0 : this.registers[inst.rs1];
                    }
                    if (inst.rs2 !== undefined) {
                        inst.rs2Val = (inst.rs2 === 0) ? 0 : this.registers[inst.rs2];
                    }
                },

                /**
                 * Estágio IF (Instruction Fetch)
                 * Busca a próxima instrução da memória.
                 * Passa para o estágio ID.
                 */
                doIF: function() {
                    // Verifica se o PC está dentro dos limites da memória de instruções
                    if (this.pc < this.instructionMemory.length) {
                        const baseInst = this.instructionMemory[this.pc];
                        
                        // Cria uma *cópia* da instrução para o pipeline
                        // Isso é VITAL para que possamos adicionar 'aluResult', etc.
                        const newInst = { ...baseInst };
                        
                        // Salva o PC atual na instrução (útil para 'jal')
                        newInst.pc = this.pc;

                        // Passa a instrução para o latch IF/ID
                        this.pipelineStages.ID = newInst;
                        // Guarda a linha para a UI
                        this.pipelineStages.IF_UI = newInst.line;
                        
                        // Incrementa o PC (ainda sem desvios)
                        this.pc++;
                    } else {
                        // Não há mais instruções
                        this.pipelineStages.ID = null;
                        this.pipelineStages.IF_UI = null;
                    }
                },

                /**
                 * Executa um único ciclo de clock
                 */
                step: function() {
                    console.log("Executando 1 ciclo (step)...");
                    
                    // Executa os estágios em ORDEM REVERSA
                    // para simular o fluxo de dados entre os latches
                    this.doWB();
                    this.doMEM();
                    this.doEX();
                    this.doID();
                    this.doIF(); // IF é o último a ser executado no código

                    // Atualiza métricas e UI
                    this.metrics.cycles++;
                    this.updateUI();
                },

                run: function() {
                    console.log("Executando simulação completa...");
                    alert("Função 'Executar (Completo)' ainda não implementada.");
                },

                // --- ATUALIZADO ---
                updateUI: function() {
                    // Função helper para obter a linha de texto da instrução no latch
                    const getLine = (stage) => this.pipelineStages[stage]?.line ?? 'vazio';

                    // 1. Atualizar Pipeline
                    this.ui.pipeline.if.textContent = this.pipelineStages.IF_UI ?? 'vazio';
                    this.ui.pipeline.id.textContent = getLine('ID');
                    this.ui.pipeline.ex.textContent = getLine('EX');
                    this.ui.pipeline.mem.textContent = getLine('MEM');
                    this.ui.pipeline.wb.textContent = getLine('WB');

                    // 2. Atualizar Registradores
                    for (let i = 0; i < 32; i++) {
                        const val = this.registers[i];
                        // `| 0` força o valor a ser tratado como um inteiro de 32 bits
                        const hexVal = '0x' + ((val | 0) >>> 0).toString(16).padStart(8, '0');
                        document.getElementById(`reg-hex-${i}`).textContent = hexVal;
                        document.getElementById(`reg-dec-${i}`).textContent = val | 0;
                    }

                    // 3. Atualizar Métricas
                    this.ui.metrics.pc.textContent = this.pc;
                    this.ui.metrics.cycles.textContent = this.metrics.cycles;
                    this.ui.metrics.instructions.textContent = this.metrics.instructions;
                    
                    const cpi = (this.metrics.instructions > 0) ? 
                                (this.metrics.cycles / this.metrics.instructions) : 0;
                    this.ui.metrics.cpi.textContent = cpi.toFixed(2);
                }
            };

            simulator.init();
        });
    </script>

</body>
</html>